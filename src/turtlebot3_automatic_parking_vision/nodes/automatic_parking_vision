#!/usr/bin/env python
# -*- coding: utf-8 -*-

################################################################################
# Copyright 2018 ROBOTIS CO., LTD.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

# Authors: Leon Jung

import rospy
import numpy as np
import tf
from enum import Enum
from nav_msgs.msg import Odometry
from ar_track_alvar_msgs.msg import AlvarMarkers
from geometry_msgs.msg import Twist
from tf.transformations import euler_from_quaternion, quaternion_from_euler
import math
import tf2_ros
import time
from geometry_msgs.msg import Vector3
from geometry_msgs.msg import Transform
from geometry_msgs.msg import Quaternion
from geometry_msgs.msg import TransformStamped


MARKER_ID_DETECTION = 0

class AutomaticParkingVision():
    

    def __init__(self):
        

        self.sub_odom_robot = rospy.Subscriber('/odom', Odometry, self.cbGetRobotOdom, queue_size = 1)
        self.sub_info_marker = rospy.Subscriber('/ar_pose_marker', AlvarMarkers, self.cbGetMarkerOdom, queue_size = 20)


        self.pub_cmd_vel = rospy.Publisher('/cmd_vel', Twist, queue_size=1)

        self.robot_2d_pose_x = .0
        self.robot_2d_pose_y = .0
        self.robot_2d_theta = .0
        self.marker_2d_pose_x = .0
        self.marker_2d_pose_y = .0
        self.marker_2d_theta = .0

        self.previous_robot_2d_theta = .0
        self.total_robot_2d_theta = .0
        self.is_triggered = False

        self.is_sequence_finished = False

        self.is_odom_received = False

        self.is_marker_pose_received = False

        loop_rate = rospy.Rate(10) # 10hz
        
        print("reached")
        
        self.controller()
        
        loop_rate.sleep()

        rospy.on_shutdown(self.fnShutDown)

    def controller(self):
        #Create a publisher and a tf buffer, which is primed with a tf listener
            
        
        while not rospy.is_shutdown():

            #################################### end your code ###############

            if self.is_marker_pose_received is False:
                self.desired_angle_turn = -0.6
                self.fnTurn(self.desired_angle_turn)
            else:

                self.fnStop()
                br = tf2_ros.TransformBroadcaster()
                self.t = TransformStamped()

                self.t.header.frame_id = "camera"
                self.t.child_frame_id = "robot"

                self.a = TransformStamped()
                self.a.header.frame_id = "camera"
                self.a.child_frame_id = "ar"

                turtlebot_frame = self.robot_transform
                goal_frame = self.marker_transform

                self.t.transform = turtlebot_frame
                self.a.transform = goal_frame


                tfBuffer = tf2_ros.Buffer()
                tfListener = tf2_ros.TransformListener(tfBuffer)
                
                # Create a timer object that will sleep long enough to result in
                # a 10Hz publishing rate
                r = rospy.Rate(10) # 10hz

                K1 = -0.3
                K2 = 1
                x = Twist()
                x.linear = Vector3()
                x.angular = Vector3()
         
                x.linear.z = 0
                x.angular.x = 0
                x.angular.y = 0
                x.linear.x = 0





            # Loop until the node is killed with Ctrl-C
          
                self.sub_odom_robot = rospy.Subscriber('/odom', Odometry, self.cbGetRobotOdom, queue_size = 1)
                self.sub_info_marker = rospy.Subscriber('/ar_pose_marker', AlvarMarkers, self.cbGetMarkerOdom, queue_size = 1)

                self.t.transform = turtlebot_frame
                self.a.transform = goal_frame
                
                x_dist = self.a.transform.translation.x - self.t.transform.translation.x
                y_dist = 0

                threshold = 5

                if threshold < x_dist:
                    
                    self.fnShutDown()

                # trans = tfBuffer.lookup_transform(self.a.child_frame_id, self.t.child_frame_id, rospy.Time())
                # t = trans.transform.translation
                x.linear.x = 0.2
                x.linear.y = y_dist
                x.angular.z = 0
                


                # Process trans to get your state error
                # Generate a control command to send to the robot
                self.fnGoStraight()

                
                # control_command = x
                # self.pub_cmd_vel.publish(control_command)


    def cbGetRobotOdom(self, robot_odom_msg):
        if self.is_odom_received == False:
            self.is_odom_received = True 
        
        # robot_transform = self.fnGet2DRobotPose(robot_odom_msg)

        self.robot_2d_pose_x =print
        if (self.robot_2d_theta - self.previous_robot_2d_theta) > 5.:
            d_theta = (self.robot_2d_theta - self.previous_robot_2d_theta) - 2 * math.pi
        elif (self.robot_2d_theta - self.previous_robot_2d_theta) < -5.:
            d_theta = (self.robot_2d_theta - self.previous_robot_2d_theta) + 2 * math.pi
        else:
            d_theta = (self.robot_2d_theta - self.previous_robot_2d_theta)

        self.total_robot_2d_theta = self.total_robot_2d_theta + d_theta
        self.previous_robot_2d_theta = self.robot_2d_theta

        self.robot_2d_theta = self.total_robot_2d_theta

        self.robot_transform = self.fnGet2DRobotPose(robot_odom_msg)


    def cbGetMarkerOdom(self, markers_odom_msg):
        for marker_odom_msg in markers_odom_msg.markers:
            if marker_odom_msg.id == MARKER_ID_DETECTION:
                if self.is_marker_pose_received == False:
                    self.is_marker_pose_received = True
                
                self.marker_transform = self.fnGet2DMarkerPose(marker_odom_msg)

           



    def fnStop(self):
        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        self.pub_cmd_vel.publish(twist)

    def fnTurn(self, theta):
        Kp = 0.6

        angular_z = Kp * theta

        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = -angular_z
        self.pub_cmd_vel.publish(twist)

    def fnGoStraight(self):
        twist = Twist()
        twist.linear.x = 0.2
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        self.pub_cmd_vel.publish(twist)

    def fnTrackMarker(self, theta):
        Kp = 1.2

        angular_z = Kp * theta

        twist = Twist()
        twist.linear.x = 0.10
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = -angular_z
        self.pub_cmd_vel.publish(twist)      

    def fnGet2DRobotPose(self, robot_odom_msg):
        quaternion = (robot_odom_msg.pose.pose.orientation.x, robot_odom_msg.pose.pose.orientation.y, robot_odom_msg.pose.pose.orientation.z, robot_odom_msg.pose.pose.orientation.w)
        theta = tf.transformations.euler_from_quaternion(quaternion)[2]

        if theta < 0:
            theta = theta + np.pi * 2
        if theta > np.pi * 2:
            theta = theta - np.pi * 2

        pos_x = robot_odom_msg.pose.pose.position.x
        pos_y = robot_odom_msg.pose.pose.position.y

        transform = Transform()
        transform.translation = Vector3()
        transform.translation.x = pos_x
        transform.translation.y = pos_y
        transform.translation.z = 0.0
        transform.rotation = Quaternion()
        transform.rotation.w = robot_odom_msg.pose.pose.orientation.w
        transform.rotation.x = robot_odom_msg.pose.pose.orientation.x
        transform.rotation.y = robot_odom_msg.pose.pose.orientation.y
        transform.rotation.z = robot_odom_msg.pose.pose.orientation.z

        return transform

    def fnGet2DMarkerPose(self, marker_odom_msg):
        quaternion = (marker_odom_msg.pose.pose.orientation.x, marker_odom_msg.pose.pose.orientation.y, marker_odom_msg.pose.pose.orientation.z, marker_odom_msg.pose.pose.orientation.w)
        theta = tf.transformations.euler_from_quaternion(quaternion)[2]

        theta = theta + np.pi / 2.
        # rospy.loginfo("theta : %f", theta)

        if theta < 0:
            theta = theta + np.pi * 2
        if theta > np.pi * 2:
            theta = theta - np.pi * 2

        pos_x = marker_odom_msg.pose.pose.position.x
        pos_y = marker_odom_msg.pose.pose.position.y

        transform = Transform()
        transform.translation = Vector3()
        transform.translation.x = pos_x
        transform.translation.y = pos_y
        transform.translation.z = 0.0
        transform.rotation = Quaternion()
        transform.rotation.w = marker_odom_msg.pose.pose.orientation.w
        transform.rotation.x = marker_odom_msg.pose.pose.orientation.x
        transform.rotation.y = marker_odom_msg.pose.pose.orientation.y
        transform.rotation.z = marker_odom_msg.pose.pose.orientation.z



        return transform

    def fnCalcDistPoints(self, x1, x2, y1, y2):
        return math.sqrt((x1 - x2) ** 2. + (y1 - y2) ** 2.)

    def fnShutDown(self):
        rospy.loginfo("Shutting down. cmd_vel will be 0")

        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        self.pub_cmd_vel.publish(twist) 

    def main(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('automatic_parking_vision')
    node = AutomaticParkingVision()
    node.main()
